<html lang="en">
  <head>
    <meta charset="utf-8" />
    <!-- The environment that embeddinglib.js is being retrieved from. Change the environment here if necessary.-->
    <script
      type="text/javascript"
      src="https://demo.microstrategy.com/MicroStrategyLibrary/javascript/embeddinglib.js"
    ></script>
    <!-- Styles for this template-->
    <link rel="stylesheet" href="./templates/styles/filterTemplate.css" />
    <!-- Slider Javascript library from cdnjs-->
    <script
      src="https://cdnjs.cloudflare.com/ajax/libs/noUiSlider/15.5.0/nouislider.min.js"
      integrity="sha512-ZKqmaRVpwWCw7S7mEjC89jDdWRD/oMS0mlfH96mO0u3wrPYoN+lXmqvyptH4P9mY6zkoPTSy5U2SwKVXRY5tYQ=="
      crossorigin="anonymous"
      referrerpolicy="no-referrer"
    ></script>
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/noUiSlider/15.5.0/nouislider.min.css"
      integrity="sha512-qveKnGrvOChbSzAdtSs8p69eoLegyh+1hwOMbmpCViIwj7rn4oJjdmMvWOuyQlTOZgTlZA0N2PXA7iA8/2TUYA=="
      crossorigin="anonymous"
      referrerpolicy="no-referrer"
    />
  </head>

  <body>
    <div id="filterContainer" class="basic-container">
      <input type="button" class="basic-button" onclick="updateFilters()" value="Update Filters" />
      <div class="instructions-container">
        <span class="instructions-title">Instructions</span>
        <span class="instruction">1) Select the filter you want to modify</span>
        <span class="instruction">2) Change the values you want to modify in each filter</span>
        <span class="instruction"
          >For more information on using filters, visit
          <a
            href="https://www2.microstrategy.com/producthelp/Current/EmbeddingSDK/Content/topics/AddFunct_Filtering.htm"
          >
            documentation.
          </a>
        </span>
      </div>
      <div id="filterListContainer" class="example-container">
        <label for="filterList"> Current List of Filters:</label>
        <select id="filterList" onchange="showFilter(this)"></select>
        <div id="currentFilterObject">
          <label for="currentFilterObjectContent">Current Filter Object:</label>
          <span id="currentFilterObjectContent">Check console for current filter object</span>
        </div>
        <div id="attributeSelector" class="filterType basic-form-layout" style="display: none">
          <span>Filter Type: "attributeSelector"</span>
          <label for="attributeSelectorValuesContainer">
            Select the values to filter on: <br />
          </label>
          <input
            type="button"
            class="basic-button"
            id="attributeSelectorValuesSelectAll"
            value="Select All"
            onclick="selectAllAttributeValues(attributeSelector,true)"
          />

          <input
            type="button"
            class="basic-button"
            id="attributeSelectorValuesClearAll"
            value="Clear All"
            onclick="selectAllAttributeValues(attributeSelector, false)"
          />
          <div
            id="attributeSelectorValuesContainer"
            class="basic-checkbox basic-checkbox__item-list"
          ></div>
          <input
            type="button"
            value="Submit"
            class="basic-button"
            onclick="applyFilter(attributeSelector)"
          />
        </div>
        <div
          id="attributeSearchSelector"
          class="filterType basic-form-layout"
          style="display: none"
        >
          <span>Filter Type: "attributeSearchSelector"</span>
          <label for="attributeSearchSelectorValuesContainer">
            Select the values to filter on: <br />
          </label>
          <input
            type="button"
            class="basic-button"
            id="attributeSearchSelectorValuesSelectAll"
            value="Select All"
            onclick="selectAllAttributeValues(attributeSearchSelector,true)"
          />
          <input
            type="button"
            class="basic-button"
            id="attributeSearchSelectorValuesClearAll"
            value="Clear All"
            onclick="selectAllAttributeValues(attributeSearchSelector, false)"
          />
          <div
            id="attributeSearchSelectorValuesContainer"
            class="basic-checkbox basic-checkbox__item-list"
          >
            <span>No values found</span>
          </div>
          <input
            type="button"
            value="Submit"
            class="basic-button"
            onclick="applyFilter(attributeSearchSelector)"
          />
        </div>
        <div id="attributeSlider" class="filterType basic-form-layout" style="display: none">
          <span>Filter Type: "attributeSlider"</span>

          <span> Drag the values to filter on: </span>
          <div
            id="attributeSliderValuesContainer"
            class="basic-checkbox basic-checkbox__item-list"
          ></div>
          <label for="attributeSliderValuesInfoText">Values:</label>
          <span id="attributeSliderValuesInfoText"></span>

          <label for="attributeSliderValuesInfoIndex">Indexes:</label>
          <span id="attributeSliderValuesInfoIndex"></span>

          <input
            type="button"
            value="Submit"
            class="basic-button"
            onclick="applyFilter(attributeSlider)"
          />
        </div>
        <div id="calendar" class="filterType basic-form-layout" style="display: none">
          <span>Filter Type: "calendar"</span>
          <label for="calendarFrom">from:</label>
          <input type="date" id="calendarFrom" />
          <label for="calendarTo">to:</label>
          <input type="date" id="calendarTo" />
          <input type="button" value="Submit" onclick="applyFilter(calendar)" />
        </div>
        <div id="metricQualByValue" class="filterType basic-form-layout" style="display: none">
          <span>Filter Type: "metricQualByValue"</span>
          <label for="metricQualByValueOperator">Operators:</label>
          <select id="metricQualByValueOperator">
            <option value="equals">Equals</option>
            <option value="not equals">Not Equals</option>
            <option value="greater">Greater than</option>
            <option value="greater equal">Greater than or equals to</option>
            <option value="less">Less than</option>
            <option value="less equal">Less than or equals to</option>
            <option value="between">Between</option>
            <option value="not between">Not between</option>
            <option value="in">In</option>
            <option value="not in">Not in</option>
            <option value="is null">Is null</option>
            <option value="is not null">Is not null</option>
          </select>
          <label for="metricQualByValueFirstValue">First Value(Optional):</label>
          <input type="number" step="any" id="metricQualByValueFirstValue" />
          <label for="metricQualByValueSecondValue">Second Value(Optional):</label>
          <input type="number" step="any" id="metricQualByValueSecondValue" />
          <input
            type="button"
            value="Submit"
            class="basic-button"
            onclick="applyFilter(metricQualByValue)"
          />
        </div>
        <div id="metricQualByRank" class="filterType basic-form-layout" style="display: none">
          <span>Filter Type: "metricQualByRank"</span>
          <label for="metricQualByRankQualType">Qualify by:</label>
          <select id="metricQualByRankQualType">
            <option value="highest">Highest</option>
            <option value="lowest">Lowest</option>
            <option value="highest percent">Highest %</option>
            <option value="lowest percent">Lowest %</option>
          </select>
          <label for="metricQualByRankValue">Value:</label>
          <input type="number" step="any" id="metricQualByRankValue" />

          <input
            type="button"
            value="Submit"
            class="basic-button"
            onclick="applyFilter(metricQualByRank)"
          />
        </div>
        <div id="metricSliderByValue" class="filterType basic-form-layout" style="display: none">
          <span>Filter Type: "metricSliderByValue"</span>

          <span> Drag the values to filter on: </span>
          <div
            id="metricSliderByValueValuesContainer"
            class="basic-checkbox basic-checkbox__item-list"
          ></div>
          <label for="metricSliderByValueValuesInfoText">Values:</label>
          <span id="metricSliderByValueValuesInfoText"></span>

          <input
            type="button"
            value="Submit"
            class="basic-button"
            onclick="applyFilter(metricSliderByValue)"
          />
        </div>
        <div id="metricSliderByRank" class="filterType basic-form-layout" style="display: none">
          <span>Filter Type: "metricSliderByRank"</span>

          <label for="metricSliderByRankQualType">Qualify by:</label>
          <select id="metricSliderByRankQualType">
            <option value="highest">Highest</option>
            <option value="lowest">Lowest</option>
            <option value="highest percent">Highest %</option>
            <option value="lowest percent">Lowest %</option>
          </select>

          <span> Drag the values to filter on: </span>
          <div
            id="metricSliderByRankValuesContainer"
            class="basic-checkbox basic-checkbox__item-list"
          ></div>
          <label for="metricSliderByRankValuesInfoText">Values:</label>
          <span id="metricSliderByRankValuesInfoText"></span>

          <input
            type="button"
            value="Submit"
            class="basic-button"
            onclick="applyFilter(metricSliderByRank)"
          />
        </div>
      </div>
    </div>
    <div id="embedding-dossier-container" />
    <script>
      let url =
        'https://demo.microstrategy.com/MicroStrategyLibrary/app/EC70648611E7A2F962E90080EFD58751/58FD451E1541F23210E9698F84A71985/W124--K46'; // https://{env-url}/{libraryName}/app/{projectId}/{dossierId}
      let dossier; // Variable to store the dossier created. Used by Event Handler do not remove!
      /**
       * The following constants are the supported filter types in this demo.
       * For the full list of filters, visit: https://www2.microstrategy.com/producthelp/Current/EmbeddingSDK/Content/topics/AddFunct_Filtering.htm
       */
      const attributeSelector = 'attributeSelector'; // Variable to store string for attributeSelector filter type
      const attributeSearchSelector = 'attributeSearchSelector'; // Variable to store string for attributeSearchSelector filter type
      const attributeSlider = 'attributeSlider'; // Variable to store string for attributeSlider filter type
      const calendar = 'calendar'; // Variable to store string for calendar filter type
      const metricQualByValue = 'metricQualByValue'; // Variable to store string for metricQualByValue filter type
      const metricQualByRank = 'metricQualByRank'; // Variable to store string for metricQualByRank filter type
      const metricSliderByValue = 'metricSliderByValue'; // Variable to store string for metricSliderByValue filter type
      const metricSliderByRank = 'metricSliderByRank'; // Variable to store string for metricSliderByRank filter type

      // Function to update filters will be called in runCode() after dossier is created and onclick from Update Filters by default.
      async function updateFilters() {
        let filterList = await dossier.getFilterList();
        console.log('The list of filters is:', filterList);

        // Clear the current list before updating
        const filterListElement = document.getElementById('filterList');
        while (filterListElement.firstChild) {
          filterListElement.removeChild(filterListElement.lastChild);
        }
        if (filterList && filterList.length > 0) {
          for (filter of filterList) {
            if (filter && filter.filterKey) {
              const nameOption = document.createElement('option');
              // Value attribute can't store objects so convert to formatted string
              nameOption.value = JSON.stringify(filter, null, '\t');
              nameOption.innerText = filter.filterName;
              filterListElement.appendChild(nameOption);
            }
          }
        }
        showFilter(filterListElement);
      }

      // Function called when you select a filter. Will show the values you can change in the filter.
      function showFilter(filterListElement) {
        // Parse filter back into json
        let filter;
        try {
          filter = JSON.parse(filterListElement.value);
        } catch (error) {
          console.log('Failed to parse filter with value:', filterListElement.value);
          return;
        }
        console.log('The current filter object is:', filter);
        // Show and build the div for the filter type
        const currentFilterObjectContent = document.getElementById('currentFilterObjectContent');
        currentFilterObjectContent.setAttribute('filterkey', filter.filterKey);
        const filterTypeElements = document.getElementsByClassName('filterType');

        // Show the filterType div that is being manipulated
        for (filterTypeElement of filterTypeElements) {
          if (filterTypeElement.id != filter.filterType) {
            filterTypeElement.style = 'display: none;';
          } else {
            filterTypeElement.style = 'display:block;';
          }
        }

        switch (filter.filterType) {
          case attributeSelector: {
            const selectAllButton = document.getElementById('attributeSelectorValuesSelectAll');
            const containerElement = document.getElementById('attributeSelectorValuesContainer');
            // Remove any currently existing options
            while (containerElement.firstChild) {
              containerElement.removeChild(containerElement.lastChild);
            }
            /**
             * Check if multiple select is allowed by filter, we will show
             * radio button for single select and checkboxes for multi
             */
            if (filter.filterDetail.supportMultiple) {
              // For each item of filter we will make a checkbox
              for (item of filter.filterDetail.items) {
                const checkbox = document.createElement('input');
                checkbox.type = 'checkbox';
                checkbox.className = 'attributeSelectorValues';
                checkbox.value = item.value;
                if (item.selected) {
                  checkbox.checked = true;
                }
                const label = document.createElement('label');
                label.innerText = item.name;
                label.appendChild(checkbox);
                containerElement.appendChild(label);
              }

              // We will enable select all button
              selectAllButton.removeAttribute('disabled');

              // We will set an attribute that denotes whether the filter supportMultiple
              containerElement.supportMultiple = true;
            } else {
              // For each item of filter we will make a radio button
              for (item of filter.filterDetail.items) {
                const radio = document.createElement('input');
                radio.type = 'radio';
                radio.className = 'attributeSelectorValues';
                radio.name = 'attributeSelectorValues';
                radio.value = item.value;
                if (item.selected) {
                  radio.checked = true;
                }
                const label = document.createElement('label');
                label.innerText = item.name;
                label.appendChild(radio);
                containerElement.appendChild(label);
              }
              // We will disable select all button
              selectAllButton.disabled = true;

              // We will set an attribute that denotes whether the filter supportMultiple
              containerElement.supportMultiple = false;
            }
            // If the items are actually empty then we will have some text appended saying it's empty
            const emptyText = document.createElement('span');
            span.innerText = 'Filter detail definition contains no available values';
            break;
          }
          case attributeSearchSelector: {
            const selectAllButton = document.getElementById(
              'attributeSearchSelectorValuesSelectAll',
            );
            const containerElement = document.getElementById(
              'attributeSearchSelectorValuesContainer',
            );
            // Remove any currently existing options
            while (containerElement.firstChild) {
              containerElement.removeChild(containerElement.lastChild);
            }
            /**
             * Check if multiple select is allowed by filter, we will show
             * radio button for single select and checkboxes for multi
             */
            if (filter.filterDetail.supportMultiple) {
              // For each item of filter we will make a checkbox
              for (item of filter.filterDetail.items) {
                const checkbox = document.createElement('input');
                checkbox.type = 'checkbox';
                checkbox.className = 'attributeSearchSelectorValues';
                checkbox.value = item.value;
                if (item.selected) {
                  checkbox.checked = true;
                }
                const label = document.createElement('label');
                label.innerText = item.name;
                label.appendChild(checkbox);
                containerElement.appendChild(label);
              }

              // We will enable select all button
              selectAllButton.removeAttribute('disabled');

              // We will set an attribute that denotes whether the filter supportMultiple
              containerElement.supportMultiple = true;
            } else {
              // For each item of filter we will make a radio button
              for (item of filter.filterDetail.items) {
                const radio = document.createElement('input');
                radio.type = 'radio';
                radio.className = 'attributeSearchSelectorValues';
                radio.name = 'attributeSearchSelectorValues';
                radio.value = item.value;
                if (item.selected) {
                  radio.checked = true;
                }
                const label = document.createElement('label');
                label.innerText = item.name;
                label.appendChild(radio);
                containerElement.appendChild(label);
              }
              // We will disable select all button
              selectAllButton.disabled = true;

              // We will set an attribute that denotes whether the filter supportMultiple
              containerElement.supportMultiple = false;
            }
            // If the items are actually empty then we will have some text appended saying it's empty
            const emptyText = document.createElement('span');
            span.innerText = 'Filter detail definition contains no available values';
            break;
          }
          case attributeSlider: {
            const containerElement = document.getElementById('attributeSliderValuesContainer');
            // Remove any currently existing options
            while (containerElement.firstChild) {
              containerElement.removeChild(containerElement.lastChild);
            }
            const sliderElement = document.createElement('div');
            sliderElement.id = 'attributeSliderValues';
            containerElement.appendChild(sliderElement);
            const indexInfo = filter.filterDetail.indexInfo;
            // Check if there is the necessary information on indexes of values on filter
            if (indexInfo) {
              /**
               * Check if multiple select is allowed by filter, we will show
               * a slider with 2 handles for multiple selections and 1 handle for single selection
               */
              if (filter.filterDetail.supportMultiple) {
                const maxRange = indexInfo.itemLength - 1 > 0 ? indexInfo.itemLength - 1 : 0;
                noUiSlider.create(sliderElement, {
                  start: [indexInfo.from, indexInfo.to],
                  step: 1,
                  connect: true,
                  range: {
                    min: [0],
                    max: [maxRange],
                  },
                  format: {
                    to: function (value) {
                      return Math.round(value);
                    },
                    from: function (value) {
                      return Number(value);
                    },
                  },
                });
                // We will set an attribute that denotes whether the filter supportMultiple
                containerElement.supportMultiple = true;
              } else {
                const maxRange = indexInfo.itemLength - 1 > 0 ? indexInfo.itemLength - 1 : 0;
                noUiSlider.create(sliderElement, {
                  start: [indexInfo.value],
                  step: 1,
                  range: {
                    min: [0],
                    max: [maxRange],
                  },
                });
                // We will set an attribute that denotes whether the filter supportMultiple
                containerElement.supportMultiple = false;
              }
              const valuesTextInfo = document.getElementById('attributeSliderValuesInfoText');
              const valuesIndexInfo = document.getElementById('attributeSliderValuesInfoIndex');
              // Every time the slider updates, we want to update the info text div
              sliderElement.noUiSlider.on('update', function (values) {
                const items = filter.filterDetail.items;
                if (items && items.length > 0) {
                  let textArray = values.map((value) => {
                    return items[value].name;
                  });
                  valuesTextInfo.innerHTML = textArray.join('-');
                  valuesIndexInfo.innerHTML = values.join('-');
                }
              });
            }
            break;
          }
          case calendar: {
            const calendarFrom = document.getElementById('calendarFrom');
            const calendarTo = document.getElementById('calendarTo');

            calendarFrom.value = convertDateToHTML5(filter.filterDetail.from);
            calendarFrom.min = convertDateToHTML5(filter.filterDetail.minDate);
            calendarFrom.max = convertDateToHTML5(filter.filterDetail.maxDate);
            calendarTo.value = convertDateToHTML5(filter.filterDetail.to);
            calendarTo.min = convertDateToHTML5(filter.filterDetail.minDate);
            calendarTo.max = convertDateToHTML5(filter.filterDetail.maxDate);
            break;
          }
          case metricQualByValue: {
            const metricQualByValueOperatorElement = document.getElementById(
              'metricQualByValueOperator',
            );
            const metricQualByValueFirstValueElement = document.getElementById(
              'metricQualByValueFirstValue',
            );
            const metricQualByValueSecondValueElement = document.getElementById(
              'metricQualByValueSecondValue',
            );

            // Depending on the operator, from and to may not exist or there may just be value
            metricQualByValueOperatorElement.value = filter.filterDetail.operator;
            metricQualByValueFirstValueElement.value =
              filter.filterDetail.from || filter.filterDetail.value;
            metricQualByValueSecondValueElement.value = filter.filterDetail.to;
            break;
          }
          case metricQualByRank: {
            const metricQualByRankQualTypeElement = document.getElementById(
              'metricQualByRankQualType',
            );
            const metricQualByRankValueElement = document.getElementById('metricQualByRankValue');

            metricQualByRankQualTypeElement.value = filter.filterDetail.qualType;
            metricQualByRankValueElement.value = filter.filterDetail.value;
            break;
          }
          case metricSliderByValue: {
            const containerElement = document.getElementById('metricSliderByValueValuesContainer');
            // Remove any currently existing options
            while (containerElement.firstChild) {
              containerElement.removeChild(containerElement.lastChild);
            }
            const sliderElement = document.createElement('div');
            sliderElement.id = 'metricSliderByValueValues';
            containerElement.appendChild(sliderElement);
            const filterDetail = filter.filterDetail;
            const indexInfo = filterDetail.indexInfo;
            // Check if there is the necessary information on indexes of values on filter
            if (indexInfo) {
              noUiSlider.create(sliderElement, {
                start: [filterDetail.from, filterDetail.to],
                step: indexInfo.itemStep,
                connect: true,
                range: {
                  min: [filterDetail.min],
                  max: [filterDetail.max],
                },
                format: {
                  to: function (value) {
                    return Math.round(value);
                  },
                  from: function (value) {
                    return Number(value);
                  },
                },
              });

              const valuesTextInfo = document.getElementById('metricSliderByValueValuesInfoText');
              // Every time the slider updates, we want to update the info text div
              sliderElement.noUiSlider.on('update', function (values) {
                valuesTextInfo.innerHTML = values.join('-');
              });
            }
            break;
          }
          case metricSliderByRank: {
            const containerElement = document.getElementById('metricSliderByRankValuesContainer');
            // Remove any currently existing options
            while (containerElement.firstChild) {
              containerElement.removeChild(containerElement.lastChild);
            }
            const sliderElement = document.createElement('div');
            sliderElement.id = 'metricSliderByRankValues';
            containerElement.appendChild(sliderElement);
            const filterDetail = filter.filterDetail;
            const metricSliderByRankQualTypeElement = document.getElementById(
              'metricSliderByRankQualType',
            );
            metricSliderByRankQualTypeElement.value = filterDetail.qualType;
            const indexInfo = filterDetail.indexInfo;
            // Check if there is the necessary information on indexes of values on filter
            if (indexInfo) {
              noUiSlider.create(sliderElement, {
                start: [filterDetail.value],
                step: indexInfo.itemStep,
                range: {
                  min: [filterDetail.min],
                  max: [filterDetail.max],
                },
                format: {
                  to: function (value) {
                    return Math.round(value);
                  },
                  from: function (value) {
                    return Number(value);
                  },
                },
              });
              // Every time the slider updates, we want to update the info text div
              const valuesTextInfo = document.getElementById('metricSliderByRankValuesInfoText');
              sliderElement.noUiSlider.on('update', function (values) {
                valuesTextInfo.innerHTML = values.join('-');
              });
            }
            break;
          }
          default: {
            console.log(
              'No filter detected, unable to identify filter, or filter is not currently supported',
            );
            break;
          }
        }
      }

      // Function called when you change or submit changes to values of the selected filter
      function applyFilter(type) {
        const currentFilterObjectContent = document.getElementById('currentFilterObjectContent');
        const filterInfo = {
          key: currentFilterObjectContent.getAttribute('filterkey'),
        };
        let filterJson;
        switch (type) {
          case attributeSelector: {
            const containerElement = document.getElementById('attributeSelectorValuesContainer');
            const attributeSelectorValues =
              containerElement.getElementsByClassName('attributeSelectorValues');
            if (containerElement.supportMultiple) {
              const selections = [];
              // For each selected value add it to the array
              for (element of attributeSelectorValues) {
                if (element.checked) {
                  selections.push({ value: element.value });
                }
              }
              filterJson = {
                filterInfo: filterInfo,
                selections: selections,
              };
              dossier.filterSelectMultiAttributes(filterJson);
            } else {
              let selection = null;
              // Check what is the selected value
              for (element of attributeSelectorValues) {
                if (element.checked) {
                  selection = { value: element.value };
                  break;
                }
              }
              // Check if there was a selection made, apply it if there is. Clear the filter otherwise.
              if (selection) {
                filterJson = {
                  filterInfo: filterInfo,
                  selection: selection,
                };
                dossier.filterSelectSingleAttribute(filterJson);
              } else {
                filterJson = {
                  filterInfo: filterInfo,
                };
                dossier.filterClear(filterJson);
              }
            }
            break;
          }
          case attributeSearchSelector: {
            const containerElement = document.getElementById(
              'attributeSearchSelectorValuesContainer',
            );
            const attributeSearchSelectorValues = containerElement.getElementsByClassName(
              'attributeSearchSelectorValues',
            );
            if (containerElement.supportMultiple) {
              const selections = [];
              // For each selected value add it to the array
              for (element of attributeSearchSelectorValues) {
                if (element.checked) {
                  selections.push({ value: element.value });
                }
              }
              filterJson = {
                filterInfo: filterInfo,
                selections: selections,
              };
              dossier.filterSearchMultiAttributes(filterJson);
            } else {
              let selection = null;
              // Check which is the selected value
              for (element of attributeSearchSelectorValues) {
                if (element.checked) {
                  selection = { value: element.value };
                  break;
                }
              }
              // Check if there was a selection made, apply it if there is. Clear the filter otherwise.
              if (selection) {
                filterJson = {
                  filterInfo: filterInfo,
                  selection: selection,
                };
                dossier.filterSearchSingleAttribute(filterJson);
              } else {
                filterJson = {
                  filterInfo: filterInfo,
                };
                dossier.filterClear(filterJson);
              }
            }
            break;
          }
          case attributeSlider: {
            const containerElement = document.getElementById('attributeSliderValuesContainer');
            const attributeSliderValues = document.getElementById('attributeSliderValues');
            // valuesSelected will be an array of the value at each handle or just a number if there's only 1 handle
            const valuesSelected = attributeSliderValues.noUiSlider.get();
            if (containerElement.supportMultiple) {
              filterJson = {
                filterInfo: filterInfo,
                selections: valuesSelected,
              };
              dossier.filterAttributeMultiSlider(filterJson);
            } else {
              filterJson = {
                filterInfo: filterInfo,
                selection: valuesSelected,
              };
              dossier.filterAttributeSingleSlider(filterJson);
            }
            break;
          }
          case calendar: {
            const fromElement = document.getElementById('calendarFrom');
            const toElement = document.getElementById('calendarTo');

            const date = {};
            // If there is at least one valid non empty input, apply the input(s). If not, clear the filter.
            if (fromElement.value || toElement.value) {
              if (fromElement.value) {
                date.from = convertDateToSDKCalendar(fromElement.value);
              }
              if (toElement.value) {
                date.to = convertDateToSDKCalendar(toElement.value);
              }
              filterJson = {
                filterInfo: filterInfo,
                date: date,
              };
              dossier.filterSetDateRange(filterJson);
            } else {
              filterJson = {
                filterInfo: filterInfo,
              };
              dossier.filterClear(filterJson);
            }
            break;
          }
          case metricQualByValue: {
            const operatorElement = document.getElementById('metricQualByValueOperator');
            const firstValueElement = document.getElementById('metricQualByValueFirstValue');
            const secondValueElement = document.getElementById('metricQualByValueSecondValue');
            const exp = { operator: operatorElement.value };
            if (firstValueElement.value) {
              exp.firstValue = Number(firstValueElement.value);
            }
            if (secondValueElement.value) {
              exp.lastValue = Number(secondValueElement.value);
            }
            filterJson = {
              filterInfo: filterInfo,
              exp: exp,
            };
            dossier.filterSetMetricQualByValue(filterJson);
            break;
          }
          case metricQualByRank: {
            const qualTypeElement = document.getElementById('metricQualByRankQualType');
            const valueElement = document.getElementById('metricQualByRankValue');
            const exp = {
              qualType: qualTypeElement.value,
              value: Number(valueElement.value),
            };
            filterJson = {
              filterInfo: filterInfo,
              exp: exp,
            };
            dossier.filterSetMetricQualByRank(filterJson);
            break;
          }
          case metricSliderByValue: {
            const metricSliderValues = document.getElementById('metricSliderByValueValues');
            // valuesSelected will be an array of the value at each handle or just a number if there's only 1 handle
            const valuesSelected = metricSliderValues.noUiSlider.get();

            filterJson = {
              filterInfo: filterInfo,
              exp: {
                range: valuesSelected,
              },
            };
            dossier.filterSetMetricSliderByValue(filterJson);
            break;
          }
          case metricSliderByRank: {
            const metricSliderValues = document.getElementById('metricSliderByRankValues');
            // valuesSelected will be an array of the value at each handle or just a number if there's only 1 handle
            const valuesSelected = metricSliderValues.noUiSlider.get();
            const metricSliderByRankQualTypeElement = document.getElementById(
              'metricSliderByRankQualType',
            );
            filterJson = {
              filterInfo: filterInfo,
              exp: {
                qualType: metricSliderByRankQualTypeElement.value,
                value: valuesSelected,
              },
            };
            dossier.filterSetMetricSliderByRank(filterJson);
            break;
          }
          default: {
            console.log('Unable to identify filter or filter is not currently supported');
            break;
          }
        }
      }

      // Function to convert date format from Embedding SDK Calendar to Input type="date"(HTML5) format
      function convertDateToHTML5(date) {
        // HTML5 Date format is yyyy-mm-dd
        // Embedding SDK Calendar format is mm/dd/yyyy
        if (date) {
          const dateArray = date.split('/');
          const year = dateArray[2];
          const month = dateArray[0];
          const day = dateArray[1];

          return year + '-' + month + '-' + day;
        } else {
          return '';
        }
      }

      // Function to convert date format from Input type="date"(HTML5) format to Embedding SDK Calendar format
      function convertDateToSDKCalendar(date) {
        // HTML5 Date format is yyyy-mm-dd
        // Embedding SDK Calendar format is mm/dd/yyyy
        if (date) {
          const dateArray = date.split('-');
          const year = dateArray[0];
          const month = dateArray[1];
          const day = dateArray[2];

          return month + '/' + day + '/' + year;
        } else {
          return '';
        }
      }

      // Function to set all attribute filter checkboxes to be true(checked) or false(unchecked)
      function selectAllAttributeValues(type, checked) {
        switch (type) {
          case attributeSelector: {
            const containerElement = document.getElementById('attributeSelectorValuesContainer');
            if (containerElement.supportMultiple) {
              const checkboxes = document.getElementsByClassName('attributeSelectorValues');
              if (checked) {
                for (checkbox of checkboxes) {
                  checkbox.checked = true;
                }
              } else {
                for (checkbox of checkboxes) {
                  checkbox.checked = false;
                }
              }
            } else {
              const radios = document.getElementsByClassName('attributeSelectorValues');
              // select all will be disabled for radio meaning checked will always be false
              if (!checked) {
                for (radio of radios) {
                  radio.checked = false;
                }
              }
            }
            break;
          }
          case attributeSearchSelector: {
            const containerElement = document.getElementById(
              'attributeSearchSelectorValuesContainer',
            );
            if (containerElement.supportMultiple) {
              const checkboxes = document.getElementsByClassName('attributeSearchSelectorValues');
              if (checked) {
                for (checkbox of checkboxes) {
                  checkbox.checked = true;
                }
              } else {
                for (checkbox of checkboxes) {
                  checkbox.checked = false;
                }
              }
            } else {
              const radios = document.getElementsByClassName('attributeSearchSelectorValues');
              // select all will be disabled for radio meaning checked will always be false
              if (!checked) {
                for (radio of radios) {
                  radio.checked = false;
                }
              }
            }
            break;
          }
          default: {
            break;
          }
        }
      }
      // Function to render the dossier
      async function runCode() {
        // For more details on configuration properties, see https://www2.microstrategy.com/producthelp/Current/EmbeddingSDK/Content/topics/dossier_properties.htm
        let config = {
          url: url,
          placeholder: document.getElementById('embedding-dossier-container'),
          navigationBar: {
            enabled: true,
            gotoLibrary: true,
            title: true,
            toc: true,
            reset: true,
            reprompt: true,
            share: true,
            comment: true,
            notification: true,
            filter: true,
            options: true,
            search: true,
            bookmark: true,
          },
          enableResponsive: true,
        };
        // INSERT PROPERTIES BELOW HERE

        // INSERT PROPERTIES ABOVE HERE

        // Embed the dossier with the configuration settings
        try {
          dossier = await window.microstrategy.dossier.create(config);
        } catch (error) {
          console.error(error);
        }
        // INSERT METHODS BELOW HERE
        updateFilters();
        function eventPageSwitchedFunction(e) {
          /* Add any functionality for event needed here */
          updateFilters();
        }

        // Update filters when page switches
        dossier.registerEventHandler(
          microstrategy.dossier.EventType.ON_PAGE_SWITCHED,
          eventPageSwitchedFunction,
        );

        // Update filters when page finishes loading
        dossier.registerEventHandler(
          microstrategy.dossier.EventType.ON_PAGE_LOADED,
          eventPageSwitchedFunction,
        );

        // INSERT METHODS ABOVE HERE
      }
      runCode();
    </script>
  </body>
</html>
